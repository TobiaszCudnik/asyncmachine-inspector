{"version":3,"sources":["src/stategraph.ts"],"names":["Node","Node.constructor","Node.relations","Node.state","Node.is_set","StateGraph","StateGraph.constructor","StateGraph.addMachine","StateGraph.bindToMachine","StateGraph.dispose","StateGraph.statesToNodes","StateGraph.getRelationsFromNode","StateGraph.getNodeByName","StateGraph.linkPipedStates","StateGraph.states"],"mappings":"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","file":"src/stategraph.js","sourcesContent":["import * as am from 'asyncmachine'\nimport Graph from 'graphs'\nimport uuid from 'node-uuid'\nimport assert from 'assert'\nimport EventEmitter from 'eventemitter3'\n\ntype MachinesMap = Map<am.AsyncMachine, string>;\ntype NodeGraph = Graph<Node>\n\nexport interface ExternalNode {\n    node: Node;\n    machine: am.AsyncMachine;\n}\n\nexport class Node {\n\n    /**\n     * Get the original state definition.\n     */\n    get state(): am.IState {\n        return this.machine.get(this.name)\n    }\n\n    /**\n     * Is the state currently set?\n     */\n    get is_set(): boolean {\n        return this.machine.is(this.name)\n    }\n\n    constructor(\n        public name: string,\n        public machine: am.AsyncMachine,\n        public machine_id: string) {\n    }\n\n    relations(node: Node | string): string[] {\n        var name = node instanceof Node\n            ? node.name : node.toString()\n        return this.machine.getRelations(this.name, name)\n    }\n}\n\n\n/**\n * TODO inherit from Graph\n */\nexport default class StateGraph extends EventEmitter {\n    graph: NodeGraph;\n    machines: MachinesMap;\n    machine_ids: { [index: string]: am.AsyncMachine };\n\n    get states() {\n        return [...this.graph.set]\n    }\n\n    constructor() {\n        super()\n        this.graph = <NodeGraph>new Graph()\n        this.machines = <MachinesMap>new Map()\n        this.machine_ids = {}\n    }\n\n    addMachine(machine: am.AsyncMachine) {\n        // TODO check for duplicates first\n        var id = uuid.v4()\n        this.machines.set(machine, id)\n        this.machine_ids[id] = machine\n        this.statesToNodes(machine.states_all, id)\n\n        for (let [machine, id] of this.machines) {\n            this.bindToMachine(machine)\n            this.linkPipedStates(machine)\n        }\n    }\n\n    private bindToMachine(machine: am.AsyncMachine) {\n        // bind to the state change\n        // TODO bind to:\n        // - piping (new and removed ones)\n        // - transition start\n        // - transition end / cancel\n        // TODO unbind on dispose\n        machine.on('change', () => this.emit('change'))\n    }\n\n    dispose() {\n        // TODO unbind listeners\n    }\n\n    private statesToNodes(names: string[], machine_id: string) {\n        // scan states\n        let new_nodes = []\n        let machine = this.machine_ids[machine_id]\n        for (let name of names) {\n            let node = new Node(name, machine, machine_id)\n            this.graph.add(node)\n            new_nodes.push(node)\n        }\n\n        // get edges from relations\n        // all the nodes have to be parsed prior to this\n        for (let node of new_nodes)\n            this.getRelationsFromNode(node, machine_id)\n    }\n\n    private getRelationsFromNode(node: Node, machine_id: string) {\n        // TODO limit to 'requires' and 'drops' ?\n        let machine = this.machine_ids[machine_id]\n        let state = node.state\n        assert(state)\n        for (let relation in state) {\n            if (relation == 'auto')\n                continue\n\n            let targets = state[relation]\n\n            for (let target_name of targets) {\n                let target = this.getNodeByName(target_name, machine_id)\n                assert(target)\n                this.graph.link(node, target)\n            }\n        }\n    }\n\n    getNodeByName(name: string, machine_id: string) {\n        for (let node of this.graph.set) {\n            if (node.name === name && node.machine_id === machine_id)\n                return node\n        }\n    }\n\n    protected linkPipedStates(machine: am.AsyncMachine) {\n        for (let state in machine.piped) {\n            var data = machine.piped[state]\n\n            let source_state = this.getNodeByName(state, this.machines.get(machine))\n            let target_state = this.getNodeByName(data.state,\n                this.machines.get(data.machine))\n            if (!target_state)\n                continue\n            this.graph.link(source_state, target_state)\n        }\n    }\n}\n"],"sourceRoot":"/source/"}