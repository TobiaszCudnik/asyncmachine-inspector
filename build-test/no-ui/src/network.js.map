{"version":3,"sources":["src/network.js","src/network.ts"],"names":["Node","Node.constructor","Node.state","Node.is_set","Node.full_name","Node.relations","Network","Network.constructor","Network.states","Network.addMachine","Network.bindToMachine","Network.dispose","Network.statesToNodes","Network.getRelationsFromNode","Network.getNodeByName","Network.linkPipedStates"],"mappings":"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","file":"src/network.js","sourcesContent":["var __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Graph = require('graphs');\nvar uuid = require('node-uuid');\nvar assert = require('assert');\n// TODO fix the declaration\n// import * as EventEmitter from 'eventemitter3'\nvar EventEmitter = require('eventemitter3');\nvar Node = (function () {\n    function Node(name, machine, machine_id) {\n        this.name = name;\n        this.machine = machine;\n        this.machine_id = machine_id;\n    }\n    Object.defineProperty(Node.prototype, \"state\", {\n        /**\n         * Get the original state definition.\n         */\n        get: function () {\n            return this.machine.get(this.name);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Node.prototype, \"is_set\", {\n        /**\n         * Is the state currently set?\n         */\n        get: function () {\n            return this.machine.is(this.name);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Node.prototype, \"full_name\", {\n        get: function () {\n            return this.machine_id + \":\" + this.name;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Node.prototype.relations = function (node) {\n        var name = node instanceof Node\n            ? node.name : node.toString();\n        return this.machine.getRelations(this.name, name);\n    };\n    return Node;\n})();\nexports.Node = Node;\n/**\n * TODO inherit from Graph\n */\nvar Network = (function (_super) {\n    __extends(Network, _super);\n    function Network() {\n        _super.call(this);\n        this.graph = new Graph();\n        this.machines = new Map();\n        this.machine_ids = {};\n        this.id = uuid.v4();\n    }\n    Object.defineProperty(Network.prototype, \"states\", {\n        get: function () {\n            return this.graph.set.slice();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Network.prototype.addMachine = function (machine) {\n        // TODO check for duplicates first\n        // TODO deterministic IDs!!!\n        var id = machine.debug_prefix || uuid.v4();\n        this.machines.set(machine, id);\n        this.machine_ids[id] = machine;\n        this.statesToNodes(machine.states_all, id);\n        this.bindToMachine(machine);\n        // TODO this is required, but should be checked\n        for (var _i = 0, _a = this.machines; _i < _a.length; _i++) {\n            var _b = _a[_i], machine_1 = _b[0], id_1 = _b[1];\n            this.linkPipedStates(machine_1);\n        }\n    };\n    Network.prototype.bindToMachine = function (machine) {\n        var _this = this;\n        // bind to the state change\n        // TODO bind to:\n        // - piping (new and removed ones)\n        // - transition start\n        // - transition end / cancel\n        // TODO unbind on dispose\n        // TODO group the same changes emitted by couple of machines\n        machine.on('change', function () { return _this.emit('change'); });\n    };\n    Network.prototype.dispose = function () {\n        // TODO unbind listeners\n    };\n    Network.prototype.statesToNodes = function (names, machine_id) {\n        // scan states\n        var new_nodes = [];\n        var machine = this.machine_ids[machine_id];\n        for (var _i = 0; _i < names.length; _i++) {\n            var name = names[_i];\n            var node = new Node(name, machine, machine_id);\n            this.graph.add(node);\n            new_nodes.push(node);\n        }\n        // get edges from relations\n        // all the nodes have to be parsed prior to this\n        for (var _a = 0; _a < new_nodes.length; _a++) {\n            var node = new_nodes[_a];\n            this.getRelationsFromNode(node, machine_id);\n        }\n    };\n    Network.prototype.getRelationsFromNode = function (node, machine_id) {\n        // TODO limit to 'requires' and 'drops' ?\n        var machine = this.machine_ids[machine_id];\n        var state = node.state;\n        assert(state);\n        for (var relation in state) {\n            if (relation == 'auto')\n                continue;\n            var targets = state[relation];\n            for (var _i = 0; _i < targets.length; _i++) {\n                var target_name = targets[_i];\n                var target = this.getNodeByName(target_name, machine_id);\n                assert(target);\n                this.graph.link(node, target);\n            }\n        }\n    };\n    Network.prototype.getNodeByName = function (name, machine_id) {\n        // for (let node of this.graph.set) {\n        var ret;\n        this.graph.set.forEach(function (node) {\n            if (node.name === name && node.machine_id === machine_id)\n                ret = node;\n        });\n        return ret;\n    };\n    Network.prototype.linkPipedStates = function (machine) {\n        for (var state in machine.piped) {\n            var data = machine.piped[state];\n            var source_state = this.getNodeByName(state, this.machines.get(machine));\n            var target_state = this.getNodeByName(data.state, this.machines.get(data.machine));\n            if (!target_state)\n                continue;\n            this.graph.link(source_state, target_state);\n        }\n    };\n    return Network;\n})(EventEmitter);\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = Network;","import * as am from 'asyncmachine'\nimport * as Graph from 'graphs'\nimport * as uuid from 'node-uuid'\nimport * as assert from 'assert'\n// TODO fix the declaration\n// import * as EventEmitter from 'eventemitter3'\nimport * as EventEmitter from 'eventemitter3'\n\ntype MachinesMap = Map<am.AsyncMachine, string>;\ntype NodeGraph = Graph<Node>\n\nexport interface ExternalNode {\n    node: Node;\n    machine: am.AsyncMachine;\n}\n\nexport class Node {\n\n    /**\n     * Get the original state definition.\n     */\n    get state(): am.IState {\n        return this.machine.get(this.name)\n    }\n\n    /**\n     * Is the state currently set?\n     */\n    get is_set(): boolean {\n        return this.machine.is(this.name)\n    }\n    \n    get full_name(): string {\n        return `${this.machine_id}:${this.name}`\n    }\n\n    constructor(\n        public name: string,\n        public machine: am.AsyncMachine,\n        public machine_id: string) {\n    }\n\n    relations(node: Node | string): string[] {\n        var name = node instanceof Node\n            ? node.name : node.toString()\n        return this.machine.getRelations(this.name, name)\n    }\n}\n\n\n/**\n * TODO inherit from Graph\n */\nexport default class Network extends EventEmitter {\n    id: string;\n    graph: NodeGraph;\n    machines: MachinesMap;\n    machine_ids: { [index: string]: am.AsyncMachine };\n\n    get states() {\n        return [...this.graph.set]\n    }\n\n    constructor() {\n        super()\n        this.graph = <NodeGraph>new Graph()\n        this.machines = <MachinesMap>new Map()\n        this.machine_ids = {}\n        this.id = uuid.v4()\n    }\n\n    addMachine(machine: am.AsyncMachine) {\n        // TODO check for duplicates first\n        // TODO deterministic IDs!!!\n        var id = machine.debug_prefix || uuid.v4()\n        this.machines.set(machine, id)\n        this.machine_ids[id] = machine\n        this.statesToNodes(machine.states_all, id)\n        this.bindToMachine(machine)\n\n        // TODO this is required, but should be checked\n        for (let [machine, id] of this.machines) {\n            this.linkPipedStates(machine)\n        }\n    }\n\n    private bindToMachine(machine: am.AsyncMachine) {\n        // bind to the state change\n        // TODO bind to:\n        // - piping (new and removed ones)\n        // - transition start\n        // - transition end / cancel\n        // TODO unbind on dispose\n        // TODO group the same changes emitted by couple of machines\n        machine.on('change', () => this.emit('change'))\n    }\n\n    dispose() {\n        // TODO unbind listeners\n    }\n\n    private statesToNodes(names: string[], machine_id: string) {\n        // scan states\n        let new_nodes = []\n        let machine = this.machine_ids[machine_id]\n        for (let name of names) {\n            let node = new Node(name, machine, machine_id)\n            this.graph.add(node)\n            new_nodes.push(node)\n        }\n\n        // get edges from relations\n        // all the nodes have to be parsed prior to this\n        for (let node of new_nodes)\n            this.getRelationsFromNode(node, machine_id)\n    }\n\n    private getRelationsFromNode(node: Node, machine_id: string) {\n        // TODO limit to 'requires' and 'drops' ?\n        let machine = this.machine_ids[machine_id]\n        let state = node.state\n        assert(state)\n        for (let relation in state) {\n            if (relation == 'auto')\n                continue\n\n            let targets = state[relation]\n\n            for (let target_name of targets) {\n                let target = this.getNodeByName(target_name, machine_id)\n                assert(target)\n                this.graph.link(node, target)\n            }\n        }\n    }\n\n    getNodeByName(name: string, machine_id: string) {\n        // for (let node of this.graph.set) {\n        var ret\n        this.graph.set.forEach( node => {\n            if (node.name === name && node.machine_id === machine_id)\n                ret = node\n        })\n        return ret\n    }\n\n    protected linkPipedStates(machine: am.AsyncMachine) {\n        for (let state in machine.piped) {\n            var data = machine.piped[state]\n\n            let source_state = this.getNodeByName(state, this.machines.get(machine))\n            let target_state = this.getNodeByName(data.state,\n                this.machines.get(data.machine))\n            if (!target_state)\n                continue\n            this.graph.link(source_state, target_state)\n        }\n    }\n}\n"],"sourceRoot":"/source/"}