{"version":3,"sources":["stategraph.ts"],"names":["Node","Node.constructor","Node.state","Node.is_set","Node.relations","StateGraph","StateGraph.constructor","StateGraph.states","StateGraph.addMachine","StateGraph.bindToMachine","StateGraph.dispose","StateGraph.statesToNodes","StateGraph.getRelationsFromNode","StateGraph.getNodeByName","StateGraph.linkPipedStates"],"mappings":"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","file":"stategraph.js","sourcesContent":["import * as am from 'asyncmachine'\nimport Graph from 'graphs'\nimport uuid from 'node-uuid'\nimport assert from 'assert'\nimport EventEmitter from 'eventemitter3'\n\ntype MachinesMap = Map<am.AsyncMachine, string>;\ntype NodeGraph = Graph<Node>\n\nexport interface ExternalNode {\n    node: Node;\n    machine: am.AsyncMachine;\n}\n\nexport class Node {\n\n    /**\n     * Get the original state definition.\n     */\n    get state(): am.IState {\n        return this.machine.get(this.name)\n    }\n\n    /**\n     * Is the state currently set?\n     */\n    get is_set(): boolean {\n        return this.machine.is(this.name)\n    }\n\n    constructor(\n        public name: string,\n        public machine: am.AsyncMachine,\n        public machine_id: string) {\n    }\n\n    relations(node: Node | string): string[] {\n        var name = node instanceof Node\n            ? node.name : node.toString()\n        return this.machine.getRelations(this.name, name)\n    }\n}\n\n\n/**\n * TODO inherit from Graph\n */\nexport default class StateGraph extends EventEmitter {\n    graph: NodeGraph;\n    machines: MachinesMap;\n    machine_ids: { [index: string]: am.AsyncMachine };\n\n    get states() {\n        return [...this.graph.set]\n    }\n\n    constructor() {\n        super()\n        this.graph = <NodeGraph>new Graph()\n        this.machines = <MachinesMap>new Map()\n        this.machine_ids = {}\n    }\n\n    addMachine(machine: am.AsyncMachine) {\n        // TODO check for duplicates first\n        var id = uuid.v4()\n        this.machines.set(machine, id)\n        this.machine_ids[id] = machine\n        this.statesToNodes(machine.states_all, id)\n\n        for (let [machine, id] of this.machines) {\n            this.bindToMachine(machine)\n            this.linkPipedStates(machine)\n        }\n    }\n\n    private bindToMachine(machine: am.AsyncMachine) {\n        // bind to the state change\n        // TODO bind to:\n        // - piping (new and removed ones)\n        // - transition start\n        // - transition end / cancel\n        // TODO unbind on dispose\n        machine.on('change', () => this.emit('change'))\n    }\n\n    dispose() {\n        // TODO unbind listeners\n    }\n\n    private statesToNodes(names: string[], machine_id: string) {\n        // scan states\n        let new_nodes = []\n        let machine = this.machine_ids[machine_id]\n        for (let name of names) {\n            let node = new Node(name, machine, machine_id)\n            this.graph.add(node)\n            new_nodes.push(node)\n        }\n\n        // get edges from relations\n        // all the nodes have to be parsed prior to this\n        for (let node of new_nodes)\n            this.getRelationsFromNode(node, machine_id)\n    }\n\n    private getRelationsFromNode(node: Node, machine_id: string) {\n        // TODO limit to 'requires' and 'drops' ?\n        let machine = this.machine_ids[machine_id]\n        let state = node.state\n        assert(state)\n        for (let relation in state) {\n            if (relation == 'auto')\n                continue\n\n            let targets = state[relation]\n\n            for (let target_name of targets) {\n                let target = this.getNodeByName(target_name, machine_id)\n                assert(target)\n                this.graph.link(node, target)\n            }\n        }\n    }\n\n    getNodeByName(name: string, machine_id: string) {\n        for (let node of this.graph.set) {\n            if (node.name === name && node.machine_id === machine_id)\n                return node\n        }\n    }\n\n    protected linkPipedStates(machine: am.AsyncMachine) {\n        for (let state in machine.piped) {\n            var data = machine.piped[state]\n\n            let source_state = this.getNodeByName(state, this.machines.get(machine))\n            let target_state = this.getNodeByName(data.state,\n                this.machines.get(data.machine))\n            if (!target_state)\n                continue\n            this.graph.link(source_state, target_state)\n        }\n    }\n}\n"],"sourceRoot":"/source/"}